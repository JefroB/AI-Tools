# Refactoring Guidelines

## Introduction

Refactoring is essential for the long-term health and usability of the AI-Tools library. As a toolkit designed to assist AI assistants in various tasks, maintaining clean, readable, and efficient code is particularly important. This document provides guidelines for refactoring both the library's code and documentation to ensure optimal performance, maintainability, and AI assistant usability.

Good refactoring practices help us:
- Improve code readability for both humans and AI assistants
- Reduce complexity and technical debt
- Enhance testability and reliability
- Make the codebase more adaptable to changing requirements
- Optimize token usage when AI assistants process our code and documentation
- Ensure code generated by AI tools follows best practices

## Core Principles

These fundamental principles should guide all development and refactoring work:

1. **Readability First**: Code and documentation should be easy to understand for both humans and AI assistants. Clear, well-structured code reduces cognitive load and token consumption.

2. **Single Responsibility**: Each function, class, or module should have one clear purpose. This makes code easier to understand, test, and modify.

3. **Testability**: Code should be designed for easy unit and integration testing, which improves reliability and makes refactoring safer.

4. **AI-Optimized Structure**: Both code and documentation should be structured to minimize token usage while maximizing information content for AI assistants.

5. **Consistent Patterns**: Using consistent patterns and conventions throughout the codebase makes it more predictable and easier to navigate.

## Function Length and Complexity

### General Guidelines

- There is no hard limit, but consider refactoring if a function exceeds 20-30 lines of code (LOC).
- Functions exceeding 50 LOC almost certainly need refactoring.
- Line count is a guideline, not a rigid rule. Readability, testability, and the Single Responsibility Principle are more important.

### Key Questions to Ask

When evaluating a function for potential refactoring, ask yourself:

- Does this function have a single, clear purpose?
- Can I easily write unit tests for this function?
- Is the code easy to understand at a glance?
- Does the function have too many parameters (more than 3-4)?
- Are there multiple levels of nesting (if/for/while blocks)?
- Is there code duplication within the function?
- Does the function mix different levels of abstraction?

### Specific Examples Related to AI Assistants

Long, complex functions can negatively impact AI assistant performance and maintainability:

- A lengthy function that processes API responses might be difficult for an AI assistant to analyze or modify correctly.
- Complex token optimization functions become harder to debug if they handle too many edge cases in a single function.
- A function that both caches responses and analyzes metrics mixes responsibilities, making it harder for AI assistants to understand its purpose.

Example from the codebase:

```javascript
// Before refactoring: Function doing too much
const optimizeAndCachePrompt = (prompt, options) => {
  // Count tokens
  const tokenCount = countTokens(prompt);
  
  // Optimize if needed
  let optimizedPrompt = prompt;
  if (tokenCount > options.maxTokens) {
    // Complex optimization logic
    if (options.preserveStart && options.preserveEnd) {
      // Preserve both start and end
      const startChars = Math.floor(prompt.length * options.startRatio);
      const endChars = prompt.length - (prompt.length - options.maxTokens);
      optimizedPrompt = prompt.substring(0, startChars) + "..." + 
                        prompt.substring(prompt.length - endChars);
    } else if (options.preserveStart) {
      // Preserve just the start
      optimizedPrompt = prompt.substring(0, options.maxTokens) + "...";
    } else if (options.preserveEnd) {
      // Preserve just the end
      optimizedPrompt = "..." + prompt.substring(prompt.length - options.maxTokens);
    } else {
      // Just truncate
      optimizedPrompt = prompt.substring(0, options.maxTokens);
    }
  }
  
  // Generate cache key
  const cacheKey = generateCacheKey(optimizedPrompt);
  
  // Check cache
  const cachedResponse = getCachedResponse(cacheKey);
  if (cachedResponse) {
    return {
      prompt: optimizedPrompt,
      response: cachedResponse,
      fromCache: true,
      originalTokenCount: tokenCount,
      optimizedTokenCount: countTokens(optimizedPrompt)
    };
  }
  
  // Return optimized prompt
  return {
    prompt: optimizedPrompt,
    fromCache: false,
    originalTokenCount: tokenCount,
    optimizedTokenCount: countTokens(optimizedPrompt)
  };
};

// After refactoring: Split into focused functions
const countPromptTokens = (prompt) => {
  return countTokens(prompt);
};

const optimizePrompt = (prompt, options) => {
  if (countPromptTokens(prompt) <= options.maxTokens) {
    return prompt;
  }
  
  if (options.preserveStart && options.preserveEnd) {
    // Preserve both start and end
    const startChars = Math.floor(prompt.length * options.startRatio);
    const endChars = prompt.length - (prompt.length - options.maxTokens);
    return prompt.substring(0, startChars) + "..." + 
           prompt.substring(prompt.length - endChars);
  } 
  
  if (options.preserveStart) {
    // Preserve just the start
    return prompt.substring(0, options.maxTokens) + "...";
  } 
  
  if (options.preserveEnd) {
    // Preserve just the end
    return "..." + prompt.substring(prompt.length - options.maxTokens);
  }
  
  // Just truncate
  return prompt.substring(0, options.maxTokens);
};

const checkCache = (prompt) => {
  const cacheKey = generateCacheKey(prompt);
  return {
    key: cacheKey,
    response: getCachedResponse(cacheKey)
  };
};

const optimizeAndCachePrompt = (prompt, options) => {
  const originalTokenCount = countPromptTokens(prompt);
  const optimizedPrompt = optimizePrompt(prompt, options);
  const optimizedTokenCount = countPromptTokens(optimizedPrompt);
  
  const cache = checkCache(optimizedPrompt);
  
  return {
    prompt: optimizedPrompt,
    response: cache.response,
    fromCache: !!cache.response,
    originalTokenCount,
    optimizedTokenCount
  };
};
```

### Tools and Techniques

- Use the Extract Function/Method refactoring pattern to break down large functions.
- Consider using the Strategy pattern for functions with complex conditional logic.
- Leverage automated testing to ensure refactoring doesn't change behavior.
- Use ESLint with complexity rules to identify functions that need refactoring.
- Consider using JSDoc comments to clarify function purpose and parameters.

## Managing Dependencies

### Guidelines

- Minimize dependencies between modules to reduce coupling.
- Use dependency injection to make testing easier and components more reusable.
- Consider using a facade pattern to simplify complex subsystem interactions.
- Avoid circular dependencies, which make code harder to understand and test.

### Example

```javascript
// Before: Tight coupling
const analyzeApiResponse = async (url) => {
  const response = await fetch(url);
  const data = await response.json();
  // Directly depends on fetch API
};

// After: Loose coupling with dependency injection
const analyzeApiResponse = async (url, httpClient = fetch) => {
  const response = await httpClient(url);
  const data = await response.json();
  // Can now be tested with a mock HTTP client
};
```

## Error Handling Strategies

### Guidelines

- Use specific error types to make error handling more predictable.
- Centralize error handling logic to avoid duplication.
- Provide meaningful error messages that help diagnose issues.
- Consider using a Result pattern for functions that may fail.

### Example

```javascript
// Before: Inconsistent error handling
const fetchAndProcessData = async (url) => {
  try {
    const response = await fetch(url);
    const data = await response.json();
    // Process data
    return result;
  } catch (error) {
    console.error(`Error fetching ${url}: ${error.message}`);
    return null;
  }
};

// After: Consistent error handling with Result pattern
class Result {
  constructor(value, error = null) {
    this.value = value;
    this.error = error;
    this.isSuccess = error === null;
  }
  
  static success(value) {
    return new Result(value);
  }
  
  static failure(error) {
    return new Result(null, error);
  }
}

const fetchAndProcessData = async (url) => {
  try {
    const response = await fetch(url);
    const data = await response.json();
    // Process data
    return Result.success(result);
  } catch (error) {
    return Result.failure(new ApiError(url, error.message));
  }
};
```

## Code Duplication

### Guidelines

- Use the DRY (Don't Repeat Yourself) principle to eliminate duplication.
- Extract common functionality into helper functions or utility classes.
- Consider using higher-order functions for operations that differ only slightly.
- Be cautious of premature abstraction, which can make code harder to understand.

### Example

```javascript
// Before: Duplication in similar functions
const fetchUserData = async (userId) => {
  const url = `https://api.example.com/users/${userId}`;
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`Failed to fetch user data: ${response.statusText}`);
  }
  return await response.json();
};

const fetchProductData = async (productId) => {
  const url = `https://api.example.com/products/${productId}`;
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`Failed to fetch product data: ${response.statusText}`);
  }
  return await response.json();
};

// After: Extracted common functionality
const fetchData = async (endpoint, id) => {
  const url = `https://api.example.com/${endpoint}/${id}`;
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`Failed to fetch ${endpoint} data: ${response.statusText}`);
  }
  return await response.json();
};

const fetchUserData = (userId) => fetchData('users', userId);
const fetchProductData = (productId) => fetchData('products', productId);
```

## Single Responsibility Principle (SRP)

### Guidelines

- Each function should do one thing and do it well.
- Each class or module should have a single reason to change.
- Watch for "and" in function or class names, which often indicates multiple responsibilities.
- Consider using composition over inheritance to combine behaviors.

### Example

```javascript
// Before: Mixed responsibilities
class ApiClient {
  constructor(baseUrl) {
    this.baseUrl = baseUrl;
  }
  
  async fetchData(endpoint) {
    const url = `${this.baseUrl}/${endpoint}`;
    const response = await fetch(url);
    const data = await response.json();
    this.logRequest(url, data);
    this.cacheResponse(endpoint, data);
    return data;
  }
  
  logRequest(url, data) {
    console.log(`Request to ${url} returned ${data.length} items`);
  }
  
  cacheResponse(endpoint, data) {
    localStorage.setItem(`cache_${endpoint}`, JSON.stringify(data));
  }
}

// After: Separated responsibilities
class ApiClient {
  constructor(baseUrl, logger = null, cache = null) {
    this.baseUrl = baseUrl;
    this.logger = logger;
    this.cache = cache;
  }
  
  async fetchData(endpoint) {
    const url = `${this.baseUrl}/${endpoint}`;
    const response = await fetch(url);
    const data = await response.json();
    
    if (this.logger) {
      this.logger.logRequest(url, data);
    }
    
    if (this.cache) {
      this.cache.store(endpoint, data);
    }
    
    return data;
  }
}

class RequestLogger {
  logRequest(url, data) {
    console.log(`Request to ${url} returned ${data.length} items`);
  }
}

class ResponseCache {
  store(key, data) {
    localStorage.setItem(`cache_${key}`, JSON.stringify(data));
  }
  
  retrieve(key) {
    const cached = localStorage.getItem(`cache_${key}`);
    return cached ? JSON.parse(cached) : null;
  }
}
```

## Documentation Guidelines

### Guidelines for AI-Friendly Documentation

- **Be Concise**: Use fewer words to convey the same information.
- **Structure Information Hierarchically**: Use headings, lists, and tables to organize content.
- **Prioritize Important Information**: Put the most critical information first.
- **Use Consistent Terminology**: Avoid synonyms for the same concept.
- **Provide Clear Examples**: Include short, focused code examples.
- **Avoid Redundancy**: Don't repeat the same information in multiple places.
- **Use Semantic Markup**: Properly format code blocks, parameters, and return values.
- **Include Type Information**: Clearly specify parameter and return types.

### Example

```markdown
<!-- Before: Verbose documentation -->
# The Token Optimization Function

The Token Optimization function is a very useful function that allows you to optimize prompts for token usage. It takes a prompt string as input and returns an optimized version of the prompt. The optimization includes truncating the prompt if it exceeds a certain token limit, and optionally preserving the start and/or end of the prompt. This function is particularly useful when you want to ensure that your prompts don't exceed the token limits of the AI model you're using.

## Usage

To use the Token Optimization function, you need to first create a prompt string. Then, you can pass this string to the function along with options for how to optimize it. The function will return an object containing the optimized prompt and some metadata about the optimization.

```javascript
const prompt = "This is a very long prompt that might exceed token limits...";
const options = {
  maxTokens: 100,
  preserveStart: true,
  preserveEnd: false,
  startRatio: 0.7
};
const result = optimizePrompt(prompt, options);
console.log(result);
```

<!-- After: Concise, structured documentation -->
# Token Optimizer

Optimizes prompts to fit within token limits while preserving important content.

## Usage

```javascript
const result = optimizePrompt(prompt, {
  maxTokens: 100,
  preserveStart: true,
  preserveEnd: false,
  startRatio: 0.7
});
```

## Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| prompt | string | The prompt text to optimize |
| options | object | Configuration options |

### Options Object

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| maxTokens | number | 4000 | Maximum allowed tokens |
| preserveStart | boolean | true | Keep the beginning of the prompt |
| preserveEnd | boolean | false | Keep the end of the prompt |
| startRatio | number | 0.7 | Portion of tokens to allocate to the start when preserving both ends |

## Returns

| Property | Type | Description |
|----------|------|-------------|
| prompt | string | The optimized prompt |
| originalTokenCount | number | Token count before optimization |
| optimizedTokenCount | number | Token count after optimization |
| truncated | boolean | Whether truncation was necessary |
```

## Code Style for AI Interaction

### Guidelines for AI-Readable Code

- **Use Descriptive Names**: Clear, descriptive names reduce the need for comments.
- **Keep Lines Short**: Aim for 80-100 characters per line for better readability.
- **Use Consistent Formatting**: Follow a consistent style throughout the codebase.
- **Add Strategic Comments**: Comment on "why" rather than "what" the code does.
- **Avoid Deep Nesting**: Limit nesting to 2-3 levels for better readability.
- **Use Named Parameters**: Consider object parameters for functions with many arguments.
- **Prefer Pure Functions**: Functions with no side effects are easier to understand and test.
- **Use Consistent Return Types**: Avoid functions that return different types based on conditions.

### Example

```javascript
// Before: Hard for AI to parse
function opt(p,o){let t=countT(p);let r=p;if(t>o.m){let s,e;if(o.ps&&o.pe){s=Math.floor(p.length*o.sr);e=p.length-(p.length-o.m);r=p.substring(0,s)+"..."+p.substring(p.length-e);}else if(o.ps){r=p.substring(0,o.m)+"...";}else if(o.pe){r=p.substring(p.length-o.m);}else{r=p.substring(0,o.m);}}return{p:r,ot:t,nt:countT(r)};}

// After: AI-friendly formatting and naming
/**
 * Optimizes a prompt to fit within token limits
 * @param {string} prompt - The prompt to optimize
 * @param {Object} options - Optimization options
 * @param {number} options.maxTokens - Maximum allowed tokens
 * @param {boolean} options.preserveStart - Whether to preserve the start of the prompt
 * @param {boolean} options.preserveEnd - Whether to preserve the end of the prompt
 * @param {number} options.startRatio - Portion of tokens to allocate to the start
 * @returns {Object} Result with optimized prompt and token counts
 */
function optimizePrompt(prompt, options = {}) {
  const {
    maxTokens = 4000,
    preserveStart = true,
    preserveEnd = false,
    startRatio = 0.7
  } = options;
  
  const originalTokenCount = countTokens(prompt);
  
  // If under token limit, return original prompt
  if (originalTokenCount <= maxTokens) {
    return {
      prompt,
      originalTokenCount,
      optimizedTokenCount: originalTokenCount,
      truncated: false
    };
  }
  
  let optimizedPrompt;
  
  // Handle different preservation strategies
  if (preserveStart && preserveEnd) {
    // Preserve both start and end portions
    const startChars = Math.floor(prompt.length * startRatio);
    const endChars = prompt.length - startChars - 3; // Account for ellipsis
    optimizedPrompt = prompt.substring(0, startChars) + 
                      "..." + 
                      prompt.substring(prompt.length - endChars);
  } else if (preserveStart) {
    // Preserve just the start
    optimizedPrompt = prompt.substring(0, maxTokens) + "...";
  } else if (preserveEnd) {
    // Preserve just the end
    optimizedPrompt = "..." + prompt.substring(prompt.length - maxTokens);
  } else {
    // Simple truncation
    optimizedPrompt = prompt.substring(0, maxTokens);
  }
  
  const optimizedTokenCount = countTokens(optimizedPrompt);
  
  return {
    prompt: optimizedPrompt,
    originalTokenCount,
    optimizedTokenCount,
    truncated: true
  };
}
```

## Guidelines for AI-Generated Code

When using AI tools to generate code, ensure the generated code follows these guidelines:

### Structure and Organization

- **Modular Design**: Generated code should be organized into logical modules with clear responsibilities.
- **Consistent Style**: Generated code should follow the same style conventions as the rest of the codebase.
- **Appropriate Abstraction**: Generated code should use appropriate levels of abstraction, avoiding both over-engineering and under-engineering.

### Documentation and Comments

- **Self-Documenting Code**: Generated code should use clear, descriptive names that reduce the need for comments.
- **Strategic Comments**: Comments should explain "why" rather than "what" the code does.
- **JSDoc Comments**: Generated functions should include JSDoc comments with parameter and return type information.

### Error Handling and Edge Cases

- **Robust Error Handling**: Generated code should include appropriate error handling for all potential failure points.
- **Edge Case Consideration**: Generated code should handle edge cases like null values, empty arrays, and invalid inputs.
- **Graceful Degradation**: Generated code should fail gracefully when errors occur.

### Testing and Validation

- **Testability**: Generated code should be designed for easy unit testing.
- **Input Validation**: Generated code should validate inputs before processing them.
- **Output Validation**: Generated code should validate outputs before returning them.

### Example of Good AI-Generated Code

```javascript
/**
 * Processes API responses and extracts relevant data
 * @param {Object} response - The API response object
 * @param {Object} options - Processing options
 * @param {string[]} options.fields - Fields to extract from each item
 * @param {Function} options.transform - Optional transformation function
 * @param {boolean} options.includeMetadata - Whether to include metadata
 * @returns {Object} Processed data with extracted items and metadata
 * @throws {Error} If response is invalid or processing fails
 */
function processApiResponse(response, options = {}) {
  // Validate inputs
  if (!response || typeof response !== 'object') {
    throw new Error('Invalid API response: response must be an object');
  }
  
  const {
    fields = [],
    transform = (item) => item,
    includeMetadata = false
  } = options;
  
  // Extract items with error handling
  let items = [];
  try {
    items = response.data || response.items || response.results || [];
    
    if (!Array.isArray(items)) {
      throw new Error('Invalid API response: items must be an array');
    }
  } catch (error) {
    throw new Error(`Failed to extract items: ${error.message}`);
  }
  
  // Process items
  const processedItems = items.map((item) => {
    // Extract specified fields or use the whole item
    const extractedItem = fields.length > 0
      ? fields.reduce((acc, field) => {
          if (item[field] !== undefined) {
            acc[field] = item[field];
          }
          return acc;
        }, {})
      : { ...item };
    
    // Apply transformation if provided
    return transform(extractedItem);
  });
  
  // Prepare result
  const result = {
    items: processedItems,
    count: processedItems.length
  };
  
  // Include metadata if requested
  if (includeMetadata && response.metadata) {
    result.metadata = response.metadata;
  }
  
  return result;
}
```

## Version Control Integration

When integrating the AI-Tools library into your project, it's recommended to add it to your .gitignore file to prevent it from being tracked by Git.

### Adding AI-Tools to .gitignore

Add the following entry to your project's .gitignore file:

```
# AI-Tools library
ai-tools/
node_modules/ai-tools/
```

If you've installed the library in a different location, adjust the path accordingly.

## Conclusion

Refactoring is an ongoing process that improves code quality, maintainability, and usability for both humans and AI assistants. By following these guidelines, we can create a codebase that is easier to understand, extend, and maintain.

Remember that refactoring should be done incrementally and with proper testing to ensure that functionality is preserved. The goal is not to achieve perfection but to continuously improve the codebase as it evolves.
